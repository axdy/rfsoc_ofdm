-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/OFDM_Tx_HW/ofdm_tx_src_Control_Signal_Generator.vhd
-- Created: 2023-10-17 14:26:57
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ofdm_tx_src_Control_Signal_Generator
-- Source Path: OFDM_Tx_HW/OFDMTx/ControlSignalGenerator/Control Signal Generator
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY ofdm_tx_src_Control_Signal_Generator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_12_0                        :   IN    std_logic;
        enable                            :   IN    std_logic;
        preambleValid                     :   OUT   std_logic;
        dataValid                         :   OUT   std_logic;
        dataReady                         :   OUT   std_logic;
        pilotValid                        :   OUT   std_logic
        );
END ofdm_tx_src_Control_Signal_Generator;


ARCHITECTURE rtl OF ofdm_tx_src_Control_Signal_Generator IS

  -- Signals
  SIGNAL state                            : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL reg_preambleValid                : std_logic;
  SIGNAL reg_enable                       : std_logic;
  SIGNAL count_preamble                   : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL count_dataReady                  : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL count_frame                      : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL state_next                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL reg_preambleValid_next           : std_logic;
  SIGNAL reg_enable_next                  : std_logic;
  SIGNAL count_preamble_next              : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL count_dataReady_next             : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL count_frame_next                 : unsigned(13 DOWNTO 0);  -- ufix14

BEGIN
  Control_Signal_Generator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      state <= to_unsigned(16#0#, 3);
      reg_preambleValid <= '0';
      reg_enable <= '0';
      count_preamble <= to_unsigned(16#000#, 9);
      count_dataReady <= to_unsigned(16#00#, 7);
      count_frame <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_0 = '1' THEN
        state <= state_next;
        reg_preambleValid <= reg_preambleValid_next;
        reg_enable <= reg_enable_next;
        count_preamble <= count_preamble_next;
        count_dataReady <= count_dataReady_next;
        count_frame <= count_frame_next;
      END IF;
    END IF;
  END PROCESS Control_Signal_Generator_process;

  Control_Signal_Generator_output : PROCESS (count_dataReady, count_frame, count_preamble, enable, reg_enable,
       reg_preambleValid, state)
    VARIABLE dataValid1 : std_logic;
    VARIABLE state_temp : unsigned(2 DOWNTO 0);
    VARIABLE add_temp : unsigned(14 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(14 DOWNTO 0);
    VARIABLE add_temp_2 : unsigned(7 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#0000#, 15);
    add_temp_0 := to_unsigned(16#000#, 10);
    add_temp_1 := to_unsigned(16#0000#, 15);
    add_temp_2 := to_unsigned(16#00#, 8);
    state_temp := state;
    count_preamble_next <= count_preamble;
    count_dataReady_next <= count_dataReady;
    count_frame_next <= count_frame;
    -- Constants
    -- States
    -- Outputs
    reg_preambleValid_next <= '0';
    dataValid1 := '0';
    dataReady <= '0';
    pilotValid <= '0';
    IF ( NOT enable) = '1' THEN 
      state_temp := to_unsigned(16#0#, 3);
    END IF;
    CASE state_temp IS
      WHEN "000" =>
        IF (enable AND ( NOT reg_enable)) = '1' THEN 
          state_temp := to_unsigned(16#1#, 3);
        END IF;
      WHEN "001" =>
        IF enable = '1' THEN 
          IF count_preamble = to_unsigned(16#140#, 9) THEN 
            count_preamble_next <= to_unsigned(16#000#, 9);
            state_temp := to_unsigned(16#2#, 3);
          ELSE 
            add_temp_0 := resize(count_preamble, 10) + to_unsigned(16#001#, 10);
            IF add_temp_0(9) /= '0' THEN 
              count_preamble_next <= "111111111";
            ELSE 
              count_preamble_next <= add_temp_0(8 DOWNTO 0);
            END IF;
            reg_preambleValid_next <= '1';
          END IF;
        ELSE 
          count_preamble_next <= to_unsigned(16#000#, 9);
        END IF;
      WHEN "010" =>
        -- Data Valid Gen
        dataValid1 := ( NOT reg_preambleValid) AND reg_enable;
        -- Data Ready Gen
        IF dataValid1 = '1' THEN 
          IF count_dataReady > to_unsigned(16#1F#, 7) THEN 
            dataReady <= '1';
          END IF;
          -- Pilot Valid Gen
          IF (count_dataReady < to_unsigned(16#20#, 7)) AND (count_dataReady > to_unsigned(16#1B#, 7)) THEN 
            pilotValid <= '1';
          END IF;
          IF count_dataReady < to_unsigned(16#4F#, 7) THEN 
            add_temp_2 := resize(count_dataReady, 8) + to_unsigned(16#01#, 8);
            IF add_temp_2(7) /= '0' THEN 
              count_dataReady_next <= "1111111";
            ELSE 
              count_dataReady_next <= add_temp_2(6 DOWNTO 0);
            END IF;
          ELSE 
            count_dataReady_next <= to_unsigned(16#00#, 7);
          END IF;
        ELSE 
          count_dataReady_next <= to_unsigned(16#00#, 7);
        END IF;
        IF count_frame < to_unsigned(16#27AF#, 14) THEN 
          add_temp_1 := resize(count_frame, 15) + to_unsigned(16#0001#, 15);
          IF add_temp_1(14) /= '0' THEN 
            count_frame_next <= "11111111111111";
          ELSE 
            count_frame_next <= add_temp_1(13 DOWNTO 0);
          END IF;
        ELSE 
          count_frame_next <= to_unsigned(16#0000#, 14);
          state_temp := to_unsigned(16#3#, 3);
        END IF;
      WHEN "011" =>
        IF count_frame < to_unsigned(16#27AF#, 14) THEN 
          add_temp := resize(count_frame, 15) + to_unsigned(16#0001#, 15);
          IF add_temp(14) /= '0' THEN 
            count_frame_next <= "11111111111111";
          ELSE 
            count_frame_next <= add_temp(13 DOWNTO 0);
          END IF;
        ELSE 
          count_frame_next <= to_unsigned(16#0000#, 14);
          state_temp := to_unsigned(16#1#, 3);
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    -- Update registers
    reg_enable_next <= enable;
    preambleValid <= reg_preambleValid;
    dataValid <= dataValid1;
    state_next <= state_temp;
  END PROCESS Control_Signal_Generator_output;


END rtl;

